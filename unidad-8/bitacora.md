# Evidencias de la unidad 8
## Actividad 01 ðŸ’¡
1. Describe tus observaciones sobre la conexiÃ³n sonido-imagen en al menos dos de las performances vistas.
   > ### Performances 1: LE PARODY & ALBA G. CORRAL
   > La verdad la conexiÃ³n sonido-imagen es muy evidente a lo largo del video esto hace que las iamgnes se vean como una coreografÃ­a, una interpretaciÃ³n. Por un lado, el ritmo marca muchos aspectos y se pude ver como alguna sveces con este se lanzando rÃ¡faga  de partÃ­culas sincronizadas con los golpes de la percusiÃ³n.  Tambien muchas veces se ve que la musica modula el entorno alterando la poca o mucha intesidad en forma simagenes y colores dependiendo de la musica. Pero obviamnete se nota que al ser en tiempo real manejado por el artista esto le da un toque mucho mas personalidado y unico.
   >
   > ### Performances 2: Performance at Festival des Bains Numeriques #9
   > Al igual que en el video anterior, aquÃ­ el ritmo tambiÃ©n es primordial. Se nota que maneja las explosiones y el tamaÃ±o de los cÃ­rculos, pero creo que en este performance el color brilla mucho mÃ¡s; es mÃ¡s expresivo y deja ver mejor lo que se estÃ¡ interpretando. Sobre todo, la manera en que las formas se juntan, creando figuras que representan los altos y bajos de la mÃºsica, me parece increÃ­ble."
   > 
2. Explica quÃ© elementos te parecieron generativos y por quÃ© crees que cada visualizaciÃ³n serÃ­a Ãºnica.
   > Para mÃ­, los elementos generativos son claros: las formas, especialmente todo cÃ³mo algunas parecen seguir a otras, los movimientos, la velocidad con que se mueven, y por supuesto, los colores y los cambios de paleta.
   >
   > Siento que lo que hace que cada visualizaciÃ³n sea Ãºnica viene de dos fuentes. Primero, el sistema debe usar aleatoriedad para decidir cÃ³mo reacciona a la mÃºsica; esto le da un toque impredecible sin que deje de interpretar la canciÃ³n. Pero, principalmente, la clave es el factor humano. El hecho de que una persona pueda manipular los parÃ¡metros en tiempo real hace que cada presentaciÃ³n sea irrepetible, ya que depende mucho de lo que la mÃºsica le haga sentir al artista en ese preciso momento. La forma en que decide mover esos parÃ¡metros, como la intensidad o el color, siempre va a variar en cada show.

3. Comparte tu reflexiÃ³n sobre la sensaciÃ³n de â€œlivenessâ€.
   > Para mÃ­, la sensaciÃ³n de "liveness" se da principalmente por la intervenciÃ³n humana en tiempo real. Es lo que diferencia esto de un simple visualizador automÃ¡tico y lo convierte en una interpretaciÃ³n en el momento, **reflejando** lo que se **siente** en ese instante en el show. Es la combinaciÃ³n de cÃ³mo la mÃºsica te hace "sentir" algo y la decisiÃ³n tÃ©cnica de "mover los parÃ¡metros" para reaccionar a eso. Yo creo que es esa mezcla entre la lÃ³gica del sistema y el sentir humano lo que hace que cada performance sea totalmente Ãºnica e irrepetible, y **genera** esa sensaciÃ³n de**l** **"aquÃ­ y el ahora"**, **donde** tanto **tÃº** como **espectador** como el **intÃ©rprete** **estÃ¡n** **en** la misma sintonÃ­a,por lo que esta sensaciÃ³n te hace sentir que es un momento especial y me parece fundamental en este tipo de shows.

## Actividad 02
1.  La pieza musical elegida (con enlace/archivo si es posible).
    > La canciÃ³n elegida es [The Milk Cartoon de Madilyn Mei](https://www.youtube.com/watch?v=vzlgrmieUAs)
    >
#### 2. La descripciÃ³n de tu concepto visual.

> Mi concepto visual es una metÃ¡fora de la disonancia de la canciÃ³n. La protagonista, una Ãºnica luz (la Estrellita), estÃ¡ huyendo de un espacio oscuro e infinito que representa la "cacerÃ­a".
>
> La Estrellita corre por un "pasillo infinito", que es una ilusiÃ³n de formas que fluyen constantemente hacia ella. El conflicto central es la **"oscuridad"**.
>
> Mi rol es manipular esta realidad. Puedo evocar un **Pulso de Brillo (K)**, forzar un **Blackout Fugaz (L)** para simular el agotamiento, o manipular las formas y colores del entorno (RotaciÃ³n y Paletas temporales), transformando el pasaje de un sueÃ±o delicado a una pesadilla inquietante para reflejar esa lucha interna.

---

#### 3. Los inputs seleccionados y la justificaciÃ³n de por quÃ© los elegiste.

##### 3.1. Inputs Reactivos (AutomÃ¡ticos)

* **Ritmo de la CanciÃ³n (Rasgueo Urgente):** La EnergÃ­a HighMid de FFT controla la velocidad del pasillo. Vincula directamente la sensaciÃ³n de "huida" con la urgencia rÃ­tmica de la canciÃ³n.
* **TensiÃ³n ArmÃ³nica (La Oscuridad):** La intensidad de la mÃºsica manipula la paleta de colores general de las Puertas, reflejando el cambio emocional del "cuento de hadas" a la "pesadilla".
* **Movimiento de la Estrellita:** El movimiento lateral caÃ³tico (bandazos errÃ¡ticos) de la Estrella se intensifica con la mÃºsica, simulando la desesperaciÃ³n.

##### 3.2. Inputs de Performance (Manuales)

**Nota:** Todos los efectos manuales (excepto Acelerar/Frenar) tienen una duraciÃ³n de **1 segundo** o menos, enfatizando el control fugaz y dramÃ¡tico.

* **Acelerador / Freno Manual (Flechas UP/DOWN):** Permite crear **"sprints"** o momentos de **"agotamiento"** (Override de Velocidad).
* **Pulso de Brillo (Tecla K):** Es el **"Grito de Poder"** de la estrella. Aumenta temporalmente el tamaÃ±o y la luminiscencia para desafiar a la oscuridad.
* **Blackout Fugaz (Tecla L):** Simula la vulnerabilidad extrema. Apaga y enciende la luz en solo **0.2 segundos** (12 frames), creando un parpadeo rÃ¡pido.
* **RotaciÃ³n de la Realidad (Teclas Q/W):** Fuerza la rotaciÃ³n del entorno, interpretando el **retorcimiento del espacio** (inspiraciÃ³n en Alexander Calder) por 1 segundo.
* **Paletas Temporales (Teclas 1, 2, 3):** Permite cambiar el entorno visual (Warm, BW estricto, Random) temporalmente.
* **Control de DistorsiÃ³n (Flechas LEFT/RIGHT):** Permite realizar **"Gestos"** o movimientos laterales elÃ¡sticos que interpretan la evasiÃ³n y la lucha por el equilibrio.
* **Ancho del Pasillo (Repulsor):** Este control se implementÃ³ como una **fuerza repulsora fija** de la Estrellita, estableciendo su "presencia" inherente.

---

#### 4. Â¿QuÃ© algoritmos o tÃ©cnicas planeas usar y por quÃ©?

* **Sistemas de PartÃ­culas:** TÃ©cnica central para el "Pasillo Infinito" y la Estela de Luz.
* **FÃ­sica de Muelle/AmortiguaciÃ³n:** Utilizado en la Estrellita para dar un movimiento elÃ¡stico y orgÃ¡nico que simula la lucha por el equilibrio.
* **Fuerzas:** La Estrellita aplica una **fuerza repulsora fija** al entorno, la mecÃ¡nica clave de su interacciÃ³n.
* **Ruido Perlin (`noise()`):** Usado para la **"DistorsiÃ³n"** (movimiento lateral errÃ¡tico) de la Estrellita, aÃ±adiendo pÃ¡nico y vida al protagonista.
* **Control de Frame-Rate y TemporizaciÃ³n:** Uso de contadores de *frame* para gestionar los efectos manuales con **precisiÃ³n temporal** y el inicio suave de la simulaciÃ³n.
5. Tus bocetos y una explicaciÃ³n de cÃ³mo los inputs influirÃ¡n en los visuales.
   > ### Bocetos:
   >
   > > Mi concepto visual final sigue siendo una metÃ¡fora de la disonancia de la canciÃ³n, manteniendo el contraste entre el dulce *cuento de hadas* y el *terror de la cacerÃ­a*. La protagonista (la Estrellita) es la Ãºnica luz, constantemente huyendo a travÃ©s de un pasillo infinito de formas que representan la oscuridad.

### La Lucha por la Luz: ConexiÃ³n de Inputs y Visuales

#### 1.  Inputs Reactivos (La MÃºsica como Antagonista)

* **Ritmo (Rasgueo Urgente):** El pulso rÃ­tmico controla la velocidad del pasillo y de las puertas cÃ³smicas. A mayor urgencia en la canciÃ³n, mÃ¡s rÃ¡pido fluye el tÃºnel hacia la Estrellita, aumentando la sensaciÃ³n de pÃ¡nico y huida.
* **TensiÃ³n ArmÃ³nica (Tonalidad):** La intensidad de la mÃºsica mapea la paleta de colores del pasillo. Esto refleja el cambio de estado emocional, pasando de tonos suaves de "cuento de hadas" a tonos inquietantes de "pesadilla".
* **Movimiento de la Estrellita:** La Estrellita tiene un movimiento lateral caÃ³tico que se intensifica con la velocidad de la mÃºsica, simulando los "bandazos errÃ¡ticos" de desesperaciÃ³n.

#### 2.Inputs de Performance 

Estos comandos manuales crean picos de intensidad expresiva de **1 segundo** de duraciÃ³n.

* **Acelerador/Freno (Flechas UP/DOWN):** Permite hacer un *override* momentÃ¡neo de la velocidad. Se usa para crear un "sprint" dramÃ¡tico o momentos de "agotamiento".
* **Pulso de Brillo (Tecla K):** Es mi "Grito de Poder". La Estrellita y su estela duplican su tamaÃ±o y luminiscencia , desafiando a la oscuridad con un pulso de luz intensa.
* **Blackout Fugaz (Tecla L):** Simula la vulnerabilidad extrema. La luz desaparece y reaparece en solo **0.2 segundos**, creando un parpadeo rÃ¡pido como si la luz estuviera al borde de la extinciÃ³n.
* **RotaciÃ³n de la Realidad (Teclas Q/W):** Fuerza a las Puertas CÃ³smicas a rotar. Esto interpreta el retorcimiento del espacio  ante la presiÃ³n, llevando el tÃºnel a una pesadilla espiralada por 1 segundo.
* **Paletas Temporales (Teclas 1, 2, 3):** Permite cambiar el entorno visual (Warm, BW estricto, Random) para acentuar un sentimiento, volviendo a la paleta reactiva al finalizar el segundo.
* **Control de DistorsiÃ³n (Flechas LEFT/RIGHT):** Permite realizar "Gestos" o movimientos laterales elÃ¡sticos, interpretando la evasiÃ³n y la lucha por el equilibrio.

  ### Proceso
   >###1
   > El primer paso fue establecer el escenario y la protagonista. Necesitaba una "Ãºnica luz" simple y un entorno que generara la ilusiÃ³n de huida. UtilicÃ© partÃ­culas muy bÃ¡sicas para construir el pasillo infinito, configurÃ¡ndolas para que fluyeran desde el centro hacia afuera, lo que establece la perspectiva y el movimiento inicial. La Estrellita aquÃ­ es solo un punto simple en un espacio oscuro y estÃ¡tico, listo para recibir vida.
   > 
   > <img width="1136" height="846" alt="image" src="https://github.com/user-attachments/assets/97ad7d0d-6ed2-495d-ae39-98a96eec58a4" />
   >
   > ### 2
   >A continuaciÃ³n, a la estrellita le implementÃ© la fÃ­sica para darle un movimiento elÃ¡stico y estable. Lo mÃ¡s importante fue aÃ±adir la estela y el brillo, que definen a la Estrellita como una entidad de luz. La estela se creÃ³ como un rastro de partÃ­culas que se desvanece, reforzando la sensaciÃ³n de velocidad y movimiento constante a travÃ©s del pasillo.
   >    
   > ![Recording 2025-10-29 190608](https://github.com/user-attachments/assets/7b4eb9ef-74cd-4c2d-859a-efe0a622d859)
   >
   >### 3
   >introduje las formas, el elemento de arte generativo. Estas formas complejas, compuestas de capas y pÃ©talos que reaccionan al audio, se vuelven el corazÃ³n dinÃ¡mico del tÃºnel. Su apariciÃ³n y color (Azul/Morado) ahora completan el entorno, creando el pasaje en que la Estrellita debe navegar, pasando de un punto estÃ¡tico a un mundo vivo y cambiante.
   >
   > ![20251030-0600-25 4093284](https://github.com/user-attachments/assets/da912e3e-3198-40dc-baa4-c028ba0d1ce7)

   > ### 4
   > Fianlmente aÃ±adÃ­ la interactividad, transformando la simulaciÃ³n en una performance controlada. Utilizando la lÃ³gica de temporizadores y el input del teclado. Ahora puedo expresar la narrativa de supervivencia con comandos: provoco el Pulso de Brillo (K), fuerzo el Blackout (L) o manipulo el entorno con los efectos de RotaciÃ³n (Q/W) y Paletas Temporales. Estos inputs me permiten acentuar la disonancia emocional de la mÃºsica, creando la lucha por la luz en tiempo real .
   >
   > https://github.com/user-attachments/assets/07aca93a-5205-4c65-851f-85ee6cf3ed86
   >
## Actividad 03
 
 1. El cÃ³digo fuente completo de tu sketch en p5.js.
``` JS
    // SimulaciÃ³n p5.js â€” Estrellita + Puertas + Pasillo
// FINAL CODE: Incluye efectos temporales, inicio suave, correcciÃ³n BW, pulso de brillo,
// y blackout fugaz de 0.2 segundos, INDEPENDIENTE de otros efectos.

let song, fft;
let estrellita;
let pasillo = [];
let portales = [];
let trailLayer, glowLayer, portalLayer;

// portal / spacing
let portalInnerRadius, portalSpacingFraction, portalSpacing, basePortalVel, maxPortalRadio;

// pasillo color (Gris PÃ¡lido Fijo)
let currentR = 230, currentG = 230, currentB = 240, currentAlpha = 80;

// interacciÃ³n velocidad
let manualSpeed = 1.0;
let manualSpeedStep = 0.5;
let manualOverrideTimer = 0;
let manualOverrideDuration = 120; // 2 segundos

// blackout
let blackoutGlobalTimer = 0;
let blackoutGlobalDuration = 12; // âœ¨ AJUSTE: 0.2 segundos
// ---

// lÃ­mites
let wallHalf = 0;

// palette mode (se resetea a 'normal' despuÃ©s del timer)
let paletteMode = 'normal';

// rotaciÃ³n global (se resetea a 0 despuÃ©s del timer)
let portalRotationDir = 0; // -1 ccw, 0 none, +1 cw
let portalRotationSpeed = 0.02; 

// --- TEMPORIZADORES CLAVE ---
let temporaryEffectTimer = 0;
const TEMPORARY_DURATION = 60; // 60 frames = 1 segundo (Efectos Q, W, 1, 2, 3, K)

let initialDelayTimer = 0;
const INITIAL_DELAY_DURATION = 60; // 60 frames = 1 segundo (Inicio suave del Pasillo)
// ----------------------------


function preload() {
Â  song = loadSound('TheMilkCarton.mp3');
}

function setup() {
Â  createCanvas(windowWidth, windowHeight);

Â  portalLayer = createGraphics(width, height);
Â  trailLayer = createGraphics(width, height);
Â  trailLayer.noStroke();
Â  glowLayer = createGraphics(width, height);
Â  glowLayer.noStroke();

Â  fft = new p5.FFT();
Â  song.connect(fft);

Â  estrellita = new Estrellita();

Â  for (let i = 0; i < 100; i++) pasillo.push(new FormaPasillo());

Â  portalInnerRadius = width / 10;
Â  maxPortalRadio = dist(0, 0, width / 2, height / 2);
Â  portalSpacingFraction = random(0.25, 0.5);
Â  portalSpacing = portalSpacingFraction * (maxPortalRadio - portalInnerRadius);
Â  basePortalVel = 1.0;

Â  let numPortales = 5;
Â  for (let i = 0; i < numPortales; i++) {
Â  Â  let p = new PuertaCosmica();
Â  Â  p.startInnerRadius = portalInnerRadius;
Â  Â  p.maxRadio = maxPortalRadio;
Â  Â  p.velBase = basePortalVel;
Â  Â  p.radio = portalInnerRadius + i * portalSpacing;
Â  Â  portales.push(p);
Â  }

Â  colorMode(RGB, 255, 255, 255, 100);
Â  wallHalf = (width / 10) / 2;
Â  noStroke();

Â  // INICIALIZAR TEMPORIZADOR DE ANIMACIÃ“N INICIAL
Â  initialDelayTimer = INITIAL_DELAY_DURATION;
}

function draw() {
Â  fft.analyze();
Â  let energiaRasgueo = fft.getEnergy("highMid");
Â  let velocidadMundoAudio = map(energiaRasgueo, 40, 200, 0.5, 8.0, true);

Â  // 1. MANEJO DE TEMPORIZADORES GLOBALES
Â  if (manualOverrideTimer > 0) manualOverrideTimer--;
Â  if (blackoutGlobalTimer > 0) blackoutGlobalTimer--;
Â  if (initialDelayTimer > 0) initialDelayTimer--;

Â  // Reset de efectos temporales (Paleta, RotaciÃ³n, Brillo de Estrellita)
Â  if (temporaryEffectTimer > 0) {
Â  Â  temporaryEffectTimer--;
Â  } else {
Â  Â  paletteMode = 'normal'; 
Â  Â  portalRotationDir = 0; 
Â  Â  estrellita.starBrightnessMultiplier = 1.0; // Restaura el brillo al valor normal
Â  }

Â  let velocidadMundo = (manualOverrideTimer > 0) ? manualSpeed : velocidadMundoAudio;

Â  estrellita.update(velocidadMundo);

Â  for (let p of portales) p.update(velocidadMundo, energiaRasgueo);
Â  for (let f of pasillo) f.update(velocidadMundo, estrellita);

Â  portalLayer.clear();
Â  for (let p of portales) p.show(portalLayer);

Â  trailLayer.background(0, 15);
Â  for (let f of pasillo) f.show(trailLayer);

Â  glowLayer.clear();
Â  estrellita.drawGlowSource(glowLayer);
Â  glowLayer.filter(BLUR, 10);

Â  background(0);
Â  image(trailLayer, 0, 0);
Â  image(portalLayer, 0, 0);
Â  blendMode(ADD);
Â  image(glowLayer, 0, 0);
Â  blendMode(BLEND);

Â  estrellita.drawTrail();
Â  estrellita.show();

Â  // HUD MÃNIMO
Â  push();
Â  noStroke();
Â  fill(255);
Â  textSize(12);
Â  textAlign(LEFT, TOP);
Â  const currentRotation = portalRotationDir === 1 ? 'CW (T)' : portalRotationDir === -1 ? 'CCW (T)' : 'OFF';
Â  const currentPalette = paletteMode === 'normal' ? 'Normal' : `${paletteMode.toUpperCase()} (T)`;
Â  const currentBrightness = estrellita.starBrightnessMultiplier > 1.0 ? 'PULSE (T)' : 'Normal';
Â  
Â  text(`Paleta (1/2/3/0): ${currentPalette}`, 12, height - 58);
Â  text(`RotaciÃ³n (Q/W): ${currentRotation}`, 12, height - 40);
Â  text(`Brillo Estrella (K): ${currentBrightness}`, 12, height - 22);
Â  pop();
}

// ---------------- Clase PuertaCosmica (RotaciÃ³n y Color Temporal + BW Estricto) ----------------
class PuertaCosmica {
Â  constructor() {
Â  Â  this.vpX = width / 2;
Â  Â  this.vpY = height / 2;
Â  Â  this.maxRadio = maxPortalRadio || dist(0, 0, this.vpX, this.vpY);
Â  Â  this.startInnerRadius = portalInnerRadius || (width / 10);
Â  Â  this.startRadio = this.startInnerRadius * 1.0;
Â  Â  this.radio = this.startRadio;
Â  Â  this.velBase = 1.0;

Â  Â  this.strokeW = 2;
Â  Â  this.numPetals = floor(random(8, 15));
Â  Â  this.currentVel = 0;
Â  Â  this.currentEnergy = 0;
Â  Â  this.noiseSeedShape = random(1000);

Â  Â  this.layer1_shape = floor(random(3));
Â  Â  this.layer2_shape = floor(random(3));
Â  Â  this.layer3_shape = floor(random(3));
Â  Â  this.layer2_isFilled = random() > 0.5;
Â  Â  this.layer3_isFilled = random() > 0.5;
Â  Â  this.initialAlphaProgress = 0;

Â  Â  this.rotationAngle = random(TWO_PI);

Â  Â  this.currentColor = { r: 120, g: 120, b: 180 };

Â  Â  // Almacena RGB como nÃºmeros primitivos
Â  Â  this.randomColor = { r: random(60, 255), g: random(60, 255), b: random(60, 255) };
Â  }

Â  reset() {
Â  Â  this.strokeW = random(1.5, 4);
Â  Â  this.numPetals = floor(random(8, 15));
Â  Â  this.noiseSeedShape = random(1000);
Â  Â  this.layer1_shape = floor(random(3));
Â  Â  this.layer2_shape = floor(random(3));
Â  Â  this.layer3_shape = floor(random(3));
Â  Â  this.layer2_isFilled = random() > 0.5;
Â  Â  this.layer3_isFilled = random() > 0.5;

Â  Â  let inner = this.startInnerRadius || (width / 10);
Â  Â  let spacing = portalSpacing || (random(0.25, 0.5) * (this.maxRadio - inner));

Â  Â  let minRadio = Infinity;
Â  Â  for (let q of portales) if (q !== this && typeof q.radio === 'number') minRadio = min(minRadio, q.radio);

Â  Â  if (!isFinite(minRadio)) this.radio = inner;
Â  Â  else this.radio = max(inner, minRadio - spacing);

Â  Â  this.radio = constrain(this.radio, inner, this.maxRadio * 0.9);
Â  Â  this.initialAlphaProgress = 0;

Â  Â  // Almacena RGB como nÃºmeros primitivos al resetear
Â  Â  this.randomColor = { r: random(60, 255), g: random(60, 255), b: random(60, 255) };
Â  }

Â  update(velocidad, energia) {
Â  Â  this.radio += this.velBase * velocidad;
Â  Â  this.currentEnergy = energia;

Â  Â  // RotaciÃ³n: Usa el valor global
Â  Â  if (portalRotationDir !== 0) {
Â  Â  Â  this.rotationAngle += portalRotationDir * portalRotationSpeed * velocidad;
Â  Â  }

Â  Â  // CALCULAR COLOR OBJETIVO
Â  Â  let target = this.computeTargetColor(energia);

Â  Â  // Aplicar fluctuaciÃ³n Perlin
Â  Â  let per = map(noise(this.noiseSeedShape + frameCount * 0.009), 0, 1, -8, 8);

Â  Â  // Suavizado interpolando currentColor hacia target+perlin
Â  Â  this.currentColor.r = lerp(this.currentColor.r, constrain(target.r + per, 0, 255), 0.06);
Â  Â  this.currentColor.g = lerp(this.currentColor.g, constrain(target.g + per, 0, 255), 0.06);
Â  Â  this.currentColor.b = lerp(this.currentColor.b, constrain(target.b + per, 0, 255), 0.06);

    // âœ¨ AJUSTE CLAVE 1: Forzar Escala de Grises Estricta en el modo 'bw'
    // Elimina cualquier tinte residual despuÃ©s del LERP promediando los canales.
    if (paletteMode === 'bw') {
        let avg = (this.currentColor.r + this.currentColor.g + this.currentColor.b) / 3;
        this.currentColor.r = avg;
        this.currentColor.g = avg;
        this.currentColor.b = avg;
    }

Â  Â  if (this.initialAlphaProgress < 100) {
Â  Â  Â  this.initialAlphaProgress += 3 * velocidad;
Â  Â  Â  this.initialAlphaProgress = constrain(this.initialAlphaProgress, 0, 100);
Â  Â  }

Â  Â  if (this.radio > this.maxRadio) {
Â  Â  Â  this.reset();
Â  Â  }
Â  }

Â  // Devuelve un objeto {r,g,b} target segÃºn paletteMode y energÃ­a
Â  computeTargetColor(energia) {
Â  Â  if (paletteMode === 'random') {
Â  Â  Â  // Devuelve el objeto simple
Â  Â  Â  return this.randomColor; 
Â  Â  }

Â  Â  if (paletteMode === 'bw') {
Â  Â  Â  let v = map(energia, 40, 200, 40, 220, true);
Â  Â  Â  return { r: v, g: v, b: v };
Â  Â  }

Â  Â  if (paletteMode === 'warm') {
Â  Â  Â  let r = map(energia, 40, 200, 160, 255, true);
Â  Â  Â  let g = map(energia, 40, 200, 60, 150, true);
Â  Â  Â  let b = map(energia, 40, 200, 20, 80, true);
Â  Â  Â  return { r: r, g: g, b: b };
Â  Â  }

Â  Â  // normal (original reactive mapping)
Â  Â  let r = map(energia, 40, 200, 0, 255, true);
Â  Â  let g = map(energia, 40, 200, 0, 165, true);
Â  Â  let b = map(energia, 40, 200, 255, 100, true);
Â  Â  return { r: r, g: g, b: b };
Â  }

Â  show(pg) {
Â  Â  pg.push();
Â  Â  pg.translate(this.vpX, this.vpY);
Â  Â  pg.rotate(this.rotationAngle);
Â  Â  pg.colorMode(RGB, 255, 255, 255, 100);

Â  Â  // Usamos los valores ajustados (r, g, b)
Â  Â  let r = this.currentColor.r;
Â  Â  let g = this.currentColor.g;
Â  Â  let b = this.currentColor.b;
Â  Â  let baseAlpha = map(this.radio, this.startRadio, this.maxRadio, 30, 100, true);

Â  Â  // Capa 1: Color base
Â  Â  let color1 = pg.color(r, g, b, baseAlpha * 0.9);
Â  Â  let color2, color3;
    
    // âœ¨ AJUSTE CLAVE 2: NEUTRALIZAR VARIACIONES DE COLOR EN MODO BW
    if (paletteMode === 'bw') {
        // En BW, las capas secundarias deben ser el mismo gris que color1
        color2 = color1;
        color3 = color1;
    } else {
        // Modo Normal/Warm/Random: Aplica variaciÃ³n para el efecto cromÃ¡tico
        color2 = pg.color(constrain(r + 20, 0, 255), constrain(g + 10, 0, 255), constrain(b - 20, 0, 255), baseAlpha);
        color3 = pg.color(constrain(r - 20, 0, 255), constrain(g - 10, 0, 255), constrain(b + 20, 0, 255), baseAlpha);
    }

Â  Â  let angleStep = TWO_PI / this.numPetals;
Â  Â  let radioInterno = this.radio * 0.25;

Â  Â  // --- LÃ³gica de Dibujo de las 3 Capas (usando color1, color2, color3) ---
Â  Â  pg.stroke(color1);
Â  Â  pg.strokeWeight(this.strokeW * 1.5);
Â  Â  pg.noFill();
Â  Â  if (this.layer1_shape == 0 || this.layer1_shape == 2) {
Â  Â  Â  pg.ellipse(0, 0, this.radio * 2, this.radio * 2);
Â  Â  } else if (this.layer1_shape == 1) {
Â  Â  Â  pg.fill(color1);
Â  Â  Â  for (let i = 0; i < this.numPetals; i++) {
Â  Â  Â  Â  let x = this.radio * cos(angleStep * i);
Â  Â  Â  Â  let y = this.radio * sin(angleStep * i);
Â  Â  Â  Â  pg.ellipse(x, y, this.strokeW * 2, this.strokeW * 2);
Â  Â  Â  }
Â  Â  }

Â  Â  pg.stroke(color2);
Â  Â  pg.strokeWeight(this.strokeW);
Â  Â  let r_mid_ext = this.radio * 0.7;
Â  Â  let r_mid_int = radioInterno * 1.5;
Â  Â  pg.rotate(angleStep / 2.0);
Â  Â  if (this.layer2_shape == 2) pg.noFill();
Â  Â  else if (this.layer2_isFilled) pg.fill(color2);
Â  Â  else pg.noFill();
Â  Â  if (this.layer2_shape == 0) {
Â  Â  Â  for (let i = 0; i < this.numPetals; i++) {
Â  Â  Â  Â  pg.beginShape();
Â  Â  Â  Â  pg.curveVertex(r_mid_int, 0); pg.curveVertex(r_mid_int, 0);
Â  Â  Â  Â  pg.curveVertex(r_mid_ext * 0.8, -this.radio * 0.2);
Â  Â  Â  Â  pg.curveVertex(r_mid_ext, 0);
Â  Â  Â  Â  pg.curveVertex(r_mid_ext * 0.8, this.radio * 0.2);
Â  Â  Â  Â  pg.curveVertex(r_mid_int, 0); pg.curveVertex(r_mid_int, 0);
Â  Â  Â  Â  pg.endShape();
Â  Â  Â  Â  pg.rotate(angleStep);
Â  Â  Â  }
Â  Â  } else if (this.layer2_shape == 1) {
Â  Â  Â  for (let i = 0; i < this.numPetals; i++) {
Â  Â  Â  Â  pg.beginShape();
Â  Â  Â  Â  pg.curveVertex(r_mid_int, 0); pg.curveVertex(r_mid_int, 0);
Â  Â  Â  Â  pg.curveVertex(r_mid_ext, -this.radio * 0.3);
Â  Â  Â  Â  pg.curveVertex(r_mid_ext, this.radio * 0.3);
Â  Â  Â  Â  pg.curveVertex(r_mid_int, 0); pg.curveVertex(r_mid_int, 0);
Â  Â  Â  Â  pg.endShape();
Â  Â  Â  Â  pg.rotate(angleStep);
Â  Â  Â  }
Â  Â  } else if (this.layer2_shape == 2) {
Â  Â  Â  pg.ellipse(0, 0, r_mid_ext * 2, r_mid_ext * 2);
Â  Â  }
Â  Â  pg.rotate(-angleStep * this.numPetals);
Â  Â  pg.rotate(-angleStep / 2.0);

Â  Â  pg.stroke(color3);
Â  Â  pg.strokeWeight(this.strokeW);
Â  Â  if (this.layer3_shape == 1) pg.noFill();
Â  Â  else if (this.layer3_isFilled) pg.fill(color3);
Â  Â  else pg.noFill();
Â  Â  let r_inner_ext = this.radio * 0.4;
Â  Â  let r_inner_int = radioInterno;
Â  Â  if (this.layer3_shape == 0) {
Â  Â  Â  for (let i = 0; i < this.numPetals; i++) {
Â  Â  Â  Â  pg.beginShape();
Â  Â  Â  Â  pg.curveVertex(r_inner_int, 0); pg.curveVertex(r_inner_int, 0);
Â  Â  Â  Â  pg.curveVertex(r_inner_ext * 0.8, -this.radio * 0.1);
Â  Â  Â  Â  pg.curveVertex(r_inner_ext, 0);
Â  Â  Â  Â  pg.curveVertex(r_inner_ext * 0.8, this.radio * 0.1);
Â  Â  Â  Â  pg.curveVertex(r_inner_int, 0); pg.curveVertex(r_inner_int, 0);
Â  Â  Â  Â  pg.endShape();
Â  Â  Â  Â  pg.rotate(angleStep);
Â  Â  Â  }
Â  Â  } else if (this.layer3_shape == 1) {
Â  Â  Â  for (let i = 0; i < this.numPetals; i++) {
Â  Â  Â  Â  pg.beginShape();
Â  Â  Â  Â  pg.curveVertex(r_inner_ext, 0); pg.curveVertex(r_inner_ext, 0);
Â  Â  Â  Â  pg.curveVertex(r_inner_int * 1.2, -this.radio * 0.1);
Â  Â  Â  Â  pg.curveVertex(r_inner_int, 0);
Â  Â  Â  Â  pg.curveVertex(r_inner_int * 1.2, this.radio * 0.1);
Â  Â  Â  Â  pg.curveVertex(r_inner_ext, 0); pg.curveVertex(r_inner_ext, 0);
Â  Â  Â  Â  pg.endShape();
Â  Â  Â  Â  pg.rotate(angleStep);
Â  Â  Â  }
Â  Â  } else if (this.layer3_shape == 2) {
Â  Â  Â  pg.fill(color3);
Â  Â  Â  for (let i = 0; i < this.numPetals; i++) {
Â  Â  Â  Â  let x = r_inner_ext * cos(angleStep * i);
Â  Â  Â  Â  let y = r_inner_ext * sin(angleStep * i);
Â  Â  Â  Â  pg.ellipse(x, y, this.strokeW * 3, this.strokeW * 3);
Â  Â  Â  }
Â  Â  }
Â  Â  pg.pop();
Â  }
}

// ---------------- Clase Estrellita (Funciones de Dibujo + Brillo Temporal) ----------------
class Estrellita {
Â  constructor() {
Â  Â  this.baseX = width / 2;
Â  Â  this.baseY = height / 2;
Â  Â  this.currentX = this.baseX;
Â  Â  this.currentY = this.baseY;
Â  Â  this.bobTime = 0;

Â  Â  this.trailLength = 30;
Â  Â  this.trailStartWidth = 7;
Â  Â  this.trailEndWidth = 2;
Â  Â  this.trailStartAlpha = 50;
Â  Â  this.trailEndAlpha = 0;
Â  Â  this.tailWiggleTime = random(1000);

Â  Â  this.starColor = color(255, 255, 200);
Â  Â  this.starSize = 6;
Â  Â  this.glowSourceSize = this.starSize * 2.5;

    this.starBrightnessMultiplier = 1.0; 

Â  Â  this.zigzagTime = random(2000);
Â  Â  this.offset = createVector(0, 0);
Â  Â  this.vel = createVector(0, 0);
Â  Â  this.mass = 1.0;
Â  Â  this.damping = 0.92;
Â  Â  this.springK = 0.06;
Â  Â  this.repulsionTimer = 0;
Â  Â  this.repulsionDuration = 18;
Â  Â  this.blackoutTimer = 0;
Â  Â  this.blackoutDuration = 12; // âœ¨ AJUSTE: 0.2 segundos

Â  Â  this.lateralNoiseSeed = random(1000);
Â  Â  this.lateralNoiseAmp = 6.0;
Â  Â  this.lateralNoiseSpeed = 0.018;

Â  Â  this.gestureActive = false;
Â  Â  this.gestureDir = 1;
Â  Â  this.gestureFrame = 0;
Â  Â  this.gestureFramesTotal = 60;
Â  Â  this.gestureScaleX = 80;
Â  Â  this.gestureScaleY = 60;
Â  }

Â  applyForce(force) {
Â  Â  let f = p5.Vector.div(force, this.mass);
Â  Â  this.vel.add(f);
Â  }

Â  startGesture(direction, frames) {
Â  Â  this.gestureActive = true;
Â  Â  this.gestureDir = (direction >= 0) ? 1 : -1;
Â  Â  this.gestureFrame = 0;
Â  Â  this.gestureFramesTotal = frames || this.gestureFramesTotal;
Â  Â  this.vel.x += this.gestureDir * 6;
Â  }

Â  teardropPoint(t, sx, sy) {
Â  Â  let theta = map(t, 0, 1, -PI / 2, 3 * PI / 2);
Â  Â  let r = 1 - sin(theta);
Â  Â  let x = r * cos(theta) * sx;
Â  Â  let y = r * sin(theta) * sy;
Â  Â  return createVector(x, y);
Â  }

Â  update(velocidadMundo) {
Â  Â  let velocidadBobBase = 0.05;
Â  Â  let velocidadBobExtra = map(velocidadMundo, 0.5, 8, 0, 0.15);
Â  Â  let velocidadBobTotal = velocidadBobBase + velocidadBobExtra;
Â  Â  let amplitudBob = map(velocidadMundo, 0.5, 8, 1, 6);
Â  Â  let bobY = sin(this.bobTime) * amplitudBob;
Â  Â  this.bobTime += velocidadBobTotal;

Â  Â  let amplitudZigzag = map(velocidadMundo, 0.5, 8, 1, 5);
Â  Â  let zigzagX = map(noise(this.zigzagTime), 0, 1, -amplitudZigzag, amplitudZigzag);
Â  Â  this.zigzagTime += 0.01;

Â  Â  let gestureOffset = createVector(0, 0);
Â  Â  if (this.gestureActive) {
Â  Â  Â  let t = this.gestureFrame / max(1, this.gestureFramesTotal);
Â  Â  Â  gestureOffset = this.teardropPoint(t, this.gestureScaleX, this.gestureScaleY);
Â  Â  Â  gestureOffset.x *= this.gestureDir;
Â  Â  Â  this.gestureFrame++;
Â  Â  Â  if (this.gestureFrame >= this.gestureFramesTotal) this.gestureActive = false;
Â  Â  }

Â  Â  let perlinBase = map(noise(this.lateralNoiseSeed + frameCount * this.lateralNoiseSpeed), 0, 1, -1, 1);
Â  Â  let lateralPerlinX = perlinBase * this.lateralNoiseAmp;

Â  Â  let targetLateral;
Â  Â  if (this.gestureActive) {
Â  Â  Â  targetLateral = gestureOffset.x + lateralPerlinX * 0.25;
Â  Â  Â  this.offset.y = lerp(this.offset.y, gestureOffset.y * 0.35, 0.12);
Â  Â  } else {
Â  Â  Â  targetLateral = lateralPerlinX + zigzagX * 0.6;
Â  Â  Â  this.offset.y = lerp(this.offset.y, 0, 0.06);
Â  Â  }

Â  Â  this.offset.x = lerp(this.offset.x, targetLateral, 0.22);

Â  Â  this.offset.add(this.vel);
Â  Â  this.vel.mult(this.damping);

Â  Â  let spring = p5.Vector.mult(this.offset, -this.springK);
Â  Â  this.vel.add(spring);

Â  Â  if (this.repulsionTimer > 0) this.repulsionTimer--;
Â  Â  if (this.blackoutTimer > 0) this.blackoutTimer--;

Â  Â  this.currentX = this.baseX + zigzagX + this.offset.x;
Â  Â  this.currentY = this.baseY + bobY + this.offset.y;

Â  Â  this.currentX = constrain(this.currentX, this.baseX - wallHalf, this.baseX + wallHalf);
Â  }

Â  drawGlowSource(pg) {
Â  Â  if (blackoutGlobalTimer > 0 || this.blackoutTimer > 0) return;
Â  Â  pg.fill(this.starColor);
Â  Â  pg.ellipse(this.currentX, this.currentY, this.glowSourceSize * this.starBrightnessMultiplier, this.glowSourceSize * this.starBrightnessMultiplier);
Â  }

Â  show() {
Â  Â  noStroke();
Â  Â  if (blackoutGlobalTimer > 0 || this.blackoutTimer > 0) return;
Â  Â  fill(this.starColor);
Â  Â  ellipse(this.currentX, this.currentY, this.starSize * this.starBrightnessMultiplier, this.starSize * this.starBrightnessMultiplier);
Â  }

Â  drawTrail() {
Â  Â  if (blackoutGlobalTimer > 0 || this.blackoutTimer > 0) return;
Â  Â  noStroke();
Â  Â  let normX = 0, normY = 1;
Â  Â  let r = red(this.starColor), g = green(this.starColor), b = blue(this.starColor);
Â  Â  let perpX = normY, perpY = -normX;
Â  Â  for (let i = 0; i < this.trailLength; i++) {
Â  Â  Â  let progress = i / this.trailLength;
Â  Â  Â  let baseX = this.currentX + normX * i;
Â  Â  Â  let baseY = this.currentY + normY * i;
Â  Â  Â  let wiggleAmount = map(noise(this.tailWiggleTime + i * 0.1), 0, 1, -8, 8);
Â  Â  Â  let finalWiggle = wiggleAmount * progress;
Â  Â  Â  let x = baseX + perpX * finalWiggle;
Â  Â  Â  let y = baseY + perpY * finalWiggle;
Â  Â  Â  let currentWidth = lerp(this.trailStartWidth, this.trailEndWidth, progress) * this.starBrightnessMultiplier;
Â  Â  Â  let currentAlpha = lerp(this.trailStartAlpha, this.trailEndAlpha, progress);
Â  Â  Â  fill(r, g, b, currentAlpha);
Â  Â  Â  ellipse(x, y, currentWidth, currentWidth);
Â  Â  }
Â  }
}

// ---------------- Clase FormaPasillo ----------------
class FormaPasillo {
Â  constructor() {
Â  Â  this.tamCuadroOrigen = width / 10;
Â  Â  this.vpX = width / 2;
Â  Â  this.vpY = height / 2;
Â  Â  this.reset();
Â  }
Â  reset() {
Â  Â  let enLadoHorizontal = random() > 0.5;
Â  Â  let medioTamLados = this.tamCuadroOrigen / 2;
Â  Â  let tamArriba = this.tamCuadroOrigen * 0.98;
Â  Â  let tamAbajo = this.tamCuadroOrigen * 0.02;
Â  Â  let bordeSuperior = this.vpY - tamArriba;
Â  Â  let bordeInferior = this.vpY + tamAbajo;
Â  Â  let bordeIzquierdo = this.vpX - medioTamLados;
Â  Â  let bordeDerecho = this.vpX + medioTamLados;
Â  Â  if (enLadoHorizontal) {
Â  Â  Â  this.x = random(bordeIzquierdo, bordeDerecho);
Â  Â  Â  this.y = random() > 0.5 ? bordeSuperior : bordeInferior;
Â  Â  } else {
Â  Â  Â  this.x = random() > 0.5 ? bordeIzquierdo : bordeDerecho;
Â  Â  Â  this.y = random(bordeSuperior, bordeInferior);
Â  Â  }
Â  Â  let dirX = this.x - this.vpX;
Â  Â  let dirY = this.y - this.vpY;
Â  Â  let mag = sqrt(dirX * dirX + dirY * dirY);
Â  Â  if (mag === 0) mag = 0.01;
Â  Â  this.velX = dirX / mag;
Â  Â  this.velY = dirY / mag;
Â  Â  this.velBase = random(0.5, 1.5);
Â  }
Â  
Â  update(velocidadAudio, estrella) {
Â  Â  // AJUSTE: Escalar la velocidad al inicio de la simulaciÃ³n (movimiento gradual)
Â  Â  let speedScale = 1.0;
Â  Â  if (initialDelayTimer > 0) {
Â  Â  Â  speedScale = map(initialDelayTimer, INITIAL_DELAY_DURATION, 0, 0.1, 1.0, true);
Â  Â  }
Â  Â  
Â  Â  let velocidadTotal = this.velBase * velocidadAudio * speedScale;
Â  Â  this.x += this.velX * velocidadTotal;
Â  Â  this.y += this.velY * velocidadTotal;
Â  Â  let d = dist(this.x, this.y, estrella.currentX, estrella.currentY);
Â  Â  let radioRepulsion = 80;
Â  Â  if (d < radioRepulsion) {
Â  Â  Â  let repelX = this.x - estrella.currentX;
Â  Â  Â  let repelY = this.y - estrella.currentY;
Â  Â  Â  if (d > 0) { repelX /= d; repelY /= d; }
Â  Â  Â  let fuerza = map(d, 0, radioRepulsion, 5, 0);
Â  Â  Â  this.x += repelX * fuerza;
Â  Â  Â  this.y += repelY * fuerza;
Â  Â  }
Â  Â  if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) this.reset();
Â  }
Â  
Â  show(pg) {
Â  Â  pg.colorMode(RGB, 255, 255, 255, 100);
Â  Â  let distCentro = dist(this.x, this.y, this.vpX, this.vpY);
Â  Â  let maxDist = dist(0, 0, this.vpX, this.vpY);
Â  Â  let progreso = map(distCentro, 0, maxDist, 0, 1, true);
Â  Â  
Â  Â  // AJUSTE: Escalar el tamaÃ±o del punto al inicio de la simulaciÃ³n (crecimiento gradual)
Â  Â  let sizeScale = 1.0;
Â  Â  if (initialDelayTimer > 0) {
Â  Â  Â  sizeScale = map(initialDelayTimer, INITIAL_DELAY_DURATION, 0, 0, 1.0, true);
Â  Â  }
Â  Â  
Â  Â  // AJUSTE DE TAMAÃ‘O: Rango mÃ¡s sutil (0.5 a 2.5) y aplicaciÃ³n del factor de escala.
Â  Â  let tamPunto = map(progreso, 0, 1, 0.5, 2.5) * sizeScale;
Â  Â  
Â  Â  let alpha = map(distCentro, 0, maxDist, 30, 100);
Â  Â  let finalColor = color(currentR, currentG, currentB, alpha);
Â  Â  pg.fill(finalColor);
Â  Â  pg.noStroke();
Â  Â  pg.ellipse(this.x, this.y, tamPunto, tamPunto);
Â  Â  pg.stroke(finalColor);
Â  Â  pg.strokeWeight(tamPunto * 0.7);
Â  Â  let colitaX = this.x - this.velX * tamPunto * 2;
Â  Â  let colitaY = this.y - this.velY * tamPunto * 2;
Â  Â  pg.line(colitaX, colitaY, this.x, this.y);
Â  Â  pg.noStroke();
Â  }
}

// ---------------- InteracciÃ³n (teclado) ----------------
function mousePressed() {
Â  if (!song.isPlaying()) song.loop();
}

function keyPressed() {
Â  // velocidad global override
Â  if (keyCode === UP_ARROW) {
Â  Â  manualSpeed = constrain(manualSpeed + manualSpeedStep, 0.1, 12);
Â  Â  manualOverrideTimer = manualOverrideDuration;
Â  } else if (keyCode === DOWN_ARROW) {
Â  Â  manualSpeed = constrain(manualSpeed - manualSpeedStep, 0.1, 12);
Â  Â  manualOverrideTimer = manualOverrideDuration;
Â  }

Â  // gesturas laterales
Â  if (keyCode === LEFT_ARROW) estrellita.startGesture(-1, 60);
Â  else if (keyCode === RIGHT_ARROW) estrellita.startGesture(1, 60);

Â  // blackout (Solo afecta al blackout, no toca otros timers de efectos temporales)
Â  if (key === 'l' || key === 'L') {
Â  Â  blackoutGlobalTimer = blackoutGlobalDuration; // 0.2s
Â  Â  estrellita.blackoutTimer = estrellita.blackoutDuration; // 0.2s
Â  }

Â  // AJUSTE DE PALETAS TEMPORALES
Â  if (key === '1') {
Â  Â  paletteMode = 'warm';
Â  Â  temporaryEffectTimer = TEMPORARY_DURATION;
Â  } else if (key === '2') {
Â  Â  paletteMode = 'bw';
Â  Â  temporaryEffectTimer = TEMPORARY_DURATION;
Â  } else if (key === '3') {
Â  Â  paletteMode = 'random';
Â  Â  // Asigna un objeto simple {r, g, b} a cada portal
Â  Â  for (let p of portales) {
Â  Â  Â  p.randomColor = { r: random(60, 255), g: random(60, 255), b: random(60, 255) };
Â  Â  }
Â  Â  temporaryEffectTimer = TEMPORARY_DURATION;
Â  } else if (key === '0') {
Â  Â  paletteMode = 'normal';
Â  Â  temporaryEffectTimer = 0; // Desactiva directamente el timer
Â  }

Â  // AJUSTE DE ROTACIÃ“N TEMPORAL
Â  if (key === 'q' || key === 'Q') {
Â  Â  portalRotationDir = 1; // Fuerza CW
Â  Â  temporaryEffectTimer = TEMPORARY_DURATION;
Â  } else if (key === 'w' || key === 'W') {
Â  Â  portalRotationDir = -1; // Fuerza CCW
Â  Â  temporaryEffectTimer = TEMPORARY_DURATION;
Â  }

Â  // âœ¨ NUEVO: AJUSTE DE BRILLO TEMPORAL DE LA ESTRELLA
Â  if (key === 'k' || key === 'K') {
Â  Â  estrellita.starBrightnessMultiplier = 2.0; // Doble de brillo/tamaÃ±o
Â  Â  temporaryEffectTimer = TEMPORARY_DURATION;
Â  }


Â  // evitar comportamiento por defecto (scroll con flechas)
Â  return false;
}
````
 2. Un enlace a tu sketch en el editor de p5.js.
    >
    > [P5.JS WEB EDITOR | FINAL SIMULACIÃ“N](https://editor.p5js.org/LCami-Villanueva/sketches/60PL8-6Ta)
    
    
 4. Capturas de pantalla mostrando tu pieza en acciÃ³n.
    >
    > <img width="1227" height="881" alt="image" src="https://github.com/user-attachments/assets/dbd67937-a578-4a0f-b1a3-d39f491e171a" />
    >
    > <img width="1472" height="875" alt="image" src="https://github.com/user-attachments/assets/495a1b4f-7d6c-4c6a-a057-d9ad1fa0de94" />
    >
    > <img width="1620" height="870" alt="image" src="https://github.com/user-attachments/assets/162ca7f7-e6db-4173-9df6-8b637c2ff42a" />
    >
    > <img width="612" height="653" alt="image" src="https://github.com/user-attachments/assets/feb032f0-ebdb-4d5c-b62d-d2cf16346b4d" />
    
    ## AutoevaluciÃ³n:
    ### Nota Propuesta **5.0**. 

Esta nota se justifica porque en el proyecto final complete las **tres actividades requeridas de la rÃºbrica** y cumplÃ­ con el objetivo principal de la unidad: **Integrar los conceptos y tÃ©cnicas para crear una pieza de arte generativo algorÃ­tmico, interactiva y en tiempo real**. La bitÃ¡cora demuestra que el sistema pasÃ³ de vectores y partÃ­culas bÃ¡sicas a una performance controlada.

#### 2. 
* **IntegraciÃ³n de Conceptos y TÃ©cnicas:** El cÃ³digo final combina con Ã©xito la **FÃ­sica de resorte** (para el movimiento elÃ¡stico de la Estrella), las **Fuerzas** (para la repulsiÃ³n del pasillo), los **Sistemas de PartÃ­culas**, y el **Ruido Perlin** (para la distorsiÃ³n caÃ³tica).
* **DiseÃ±o e ImplementaciÃ³n de un Sistema Generativo:** Se diseÃ±Ã³ un sistema de visualizaciÃ³n que interpreta la disonancia de la canciÃ³n. Las **Puertas** (arte generativo) reaccionan al audio, y la **RotaciÃ³n** se usa como un acto expresivo en tiempo real.
* **InterpretaciÃ³n Musical en Tiempo Real (Liveness):** LogrÃ© crear una narrativa controlable. Los comandos como el **Pulso de Brillo (K)**, el **Blackout Fugaz (L) de 0.2s**, y los **Efectos Temporales** me permiten interpretar la lucha por la supervivencia de la Estrellita justo en el momento que lo exige la mÃºsica.









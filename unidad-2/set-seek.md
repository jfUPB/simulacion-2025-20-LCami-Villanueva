# Unidad 2

## üîé Fase: Set + Seek

### Actividad 01
- ¬øC√≥mo funciona la suma dos vectores en p5.js?
  
  > La suma de vetores en p5.js funciona igual que en la geometr√≠a euclidiana y bajo ese mismo concepto, sumar los componentes correspondientes de cada vector. Esto se hace atraves de la **funci√≥n .add**, esta permite que los vectore sse sumen correctamente, es decor los componente en x de un vector con los en x del otro, los componentes en y de uno con los del otro, y as√≠ depenediendo de la dimension en que se encuentre el vector. Para obtener el vector que rfepresenta la suma de los vectores originales.
  
- ¬øPor qu√© esta l√≠nea position = position + velocity; no funcio
   > No funciona porque en JavaScript el operador + est√° dise√±ado para trabajar con valores primitivos, como numeros entero, flotantes o cadenas, pero no sabe c√≥mo sumar objetos como los Vectores. Cuando escribimos position = position + velocity, estamos intentando sumar dos objetos, lo cual no est√° definido en JavaScript. Por eso, en p5.js se utiliza el m√©todo .add(), que est√° programado para realizar la suma componente a componente entre vectores.

### Actividad 02

Realiza este ejercicio del libro Ejercicio 1.1

- ¬øQu√© tuviste que hacer para hacer la conversi√≥n propuesta?
  
  > - Cambi√© dos variables (x, y) por un solo Vector.
  > - Sustitu√≠ operaciones escalares que usan (+ o -) por m√©todos del vector (.add()).
  > - Adapt√© las funciones como point() donde dibujo el punto para usar los componentes del vector.
  
- Muestra el c√≥digo que utilizaste para resolver el ejercicio.
```javascript  
let walker;

function setup() {
  createCanvas(640, 240);
  walker = new Walker();
  background(255);
}

function draw() {
  walker.step();
  walker.show();
}

class Walker {
  constructor() {
    // Us√© un vector para representar la posici√≥n
    this.position = createVector(width / 2, height / 2);
  }

  show() {
    stroke(0);
   // Adapt√© las funci√≥n para usar los componentes del vector.
    point(this.position.x, this.position.y);
  }

  step() {
    const choice = floor(random(4));
    let step = createVector(0, 0);

    if (choice == 0) {
      step.x = 1;
    } else if (choice == 1) {
      step.x = -1;
    } else if (choice == 2) {
      step.y = 1;
    } else {
      step.y = -1;
    }

    // Sum√© el paso a la posici√≥n con .add()
    this.position.add(step);
  }
}
```
### Actividad 03
 Experimenta.
- ¬øQu√© resultado esperas obtener en el programa anterior?
 > Espero que se dibuje un fondo cuadrado casi blanco y que se cree un vector con la posici√≥n (6, 9), que se va a mostrar en la consola. Luego, esa posici√≥n se va a modificar a (20, 30)      usando la funci√≥n playingVector, y esa nueva posici√≥n tambi√©n se va a imprimir en consola. Por √∫ltimo, como se usa noLoop(), el mensaje "Only once" se mostrar√° una sola vez en la   consola.
  
- ¬øQu√© resultado obtuviste?
> Mi respuesta fue b√°sicamente lo que dije, fondo cuadrado casi blanco y que se cree un vector con la posici√≥n (6, 9), que se va a mostrar en la consola. Luego, esa posici√≥n se va a modificar a (20, 30) usando la funci√≥n playingVector, y esa nueva posici√≥n tambi√©n se va a imprimir en consola. Solo que en consola se mostraron las coordenadas en tres dimensiones, o sea, apareci√≥ como (6, 9, 0) y luego como (20, 30, 0).
  
- Recuerda los conceptos de paso por valor y paso por referencia en programaci√≥n. Muestra ejemplos de este concepto en javascript.
#### **Paso por valor**
  
> Cuando pasas tipos primitivos como number, string, boolean, null, undefined, symbol, bigint, se pasa una copia del valor. Cambiar esa copia no afecta al valor original.

Ejemplo:
   ```javascript
function cambiarValor(x) {
  x = x + 1;
  console.log("Dentro de la funci√≥n:", x); // 6
}

let numero = 5;
cambiarValor(numero);
console.log("Fuera de la funci√≥n:", numero); // 5
  ```
 *Aunque se modifica x dentro de la funci√≥n, el valor original (numero) no cambia.*
 
 #### Paso por referencia
> Cuando pasas objetos o arrays (incluidos los vectores de p5.js), se pasa una referencia a la ubicaci√≥n en memoria, no una copia del contenido. Cambiar algo dentro del objeto afecta al original.

Ejemplo:
```javascript
function modificarVector(v) {
  v.x = 10;
  v.y = 20;
}

let posicion = createVector(5, 5);
modificarVector(posicion);
console.log(posicion.toString()); // Vector with components (10, 20, 0)
```
*Como posicion es un objeto, la funci√≥n puede cambiar directamente sus propiedades.*
- ¬øQu√© tipo de paso se est√° realizando en el c√≥digo?
  > En ese c√≥digo se est√° realizando un paso por referencia.
  > Porque la posici√≥n es un objeto y cuando se pasa un objeto a una funci√≥n, no se copia el objeto, sino que se pasa una referencia a su ubicaci√≥n en memoria. Es decir, ambas variables (position y v) apuntan al mismo vector.

- ¬øQu√© aprendiste?
  > Aprend√≠ que cuando paso un objeto  a una funci√≥n, en realidad no se copia, sino que se pasa la referencia, o sea, que si cambio el objeto dentro de la funci√≥n, tambi√©n se cambia por fuera. Eso se llama paso por referencia. En cambio, si fuera un n√∫mero o un string, ah√≠ s√≠ se copia el valor y no se modifica el original (paso por valor). Esto me ayud√≥ a entender por qu√© el vector position s√≠ cambi√≥ despu√©s de usar la funci√≥n playingVector() en el c√≥digo de ejemplo.


### Actividad 04

- ¬øPara qu√© sirve el m√©todo mag()? Nota que hay otro m√©todo llamado magSq(). ¬øCu√°l es la diferencia entre ambos? ¬øCu√°l es m√°s eficiente?
  > - El m√©todo mag() sirve para obtener la magnitud (o longitud) de un vector. Es equivalente a calcular la distancia desde el origen (0, 0) hasta el punto definido por el vector usando el Teorema de Pit√°goras, Con la formula Raiz(x^2 + y^2 + z^2).
  > -  El m√©todo magSq() devuelve la magnitud al cuadrado del vector, es decir, evita calcular la ra√≠z cuadrada:
  > - Desde este punto de vista el magSq() es m√°s eficiente que mag() porque no calcula la ra√≠z cuadrada, lo que ahorra recursos en operaciones repetitivas o cuando solo necesitas comparar vectores.
  
- ¬øPara qu√© sirve el m√©todo normalize()?
  > Sirve para conviertir la magnitud de un vector en uno con la misma direcci√≥n, es decir, lo transforma en un vector unitario.
     Esto para mantener la direcci√≥n del vector original, pero sin importar su magnitud. Es √∫til, cuando por ejemplo solo te interesa hacia d√≥nde apunta un objeto, pero quieres controlar t√∫ la velocidad o magnitud            aparte.
- Te encuentras con un periodista en la calle y te pregunta ¬øPara qu√© sirve el m√©todo dot()? ¬øQu√© le responder√≠as en un frase?
  > El m√©todo dot() calcula el producto punto entre dos vectores. Es como medir cu√°nta 'sombra' de un vector cae sobre el otro. Es muy √∫til para saber c√≥mo se relacionan dos direcciones en el espacio.
  
- El m√©todo dot() tiene una versi√≥n est√°tica y una de instancia. ¬øCu√°l es la diferencia entre ambas?
  > La diferencia es que la versi√≥n de instancia v1.dot(v2) se llama desde un vector y usa otro como argumento, mientras que la versi√≥n est√°tica p5.Vector.dot(v1, v2) se llama desde la clase y recibe ambos vectores   como par√°metros.
  > Por lo tanto  la versi√≥n normal se usa cuando ya tienes un vector y quieres compararlo con otro.
y la versi√≥n est√°tica (p5.Vector.dot(v1, v2)) se usa cuando quieres comparar dos vectores desde fuera, sin que uno ‚Äúllame‚Äù al otro.

- Ahora el mismo periodista curioso de antes te pregunta si le puedes dar una intuici√≥n geom√©trica acerca del producto cruz. Entonces te pregunta ¬øCu√°l es la interpretaci√≥n geom√©trica del producto cruz de dos vectores? Tu respuesta debe incluir qu√© pasa con la orientaci√≥n y la magnitud del vector resultante.
  > El producto cruz entre dos vectores se puede imaginar como un nuevo vector que es perpendicular a los dos vectores originales. Si los dos vectores est√°n en el plano, el producto cruz ‚Äúapunta‚Äù hacia afuera del plano, como si saliera hacia ti o se alejara de ti, dependiendo del orden de los vectores. En cuanto a la magnitud, el producto cruz mide el √°rea del paralelogramo formado por los dos vectores. Es decir, cu√°nto "espacio" en el plano abarcan juntos. Entonces, geom√©tricamente, la direcci√≥n del vector cruzado indica una orientaci√≥n perpendicular (hacia arriba o hacia abajo del plano). Y la magnitud te dice cu√°n separados o inclinados est√°n los vectores entre s√≠. 
- ¬øPara que te puede servir el m√©todo dist()?
  > El m√©todo dist() sirve para calcular la distancia entre dos puntos representados por sus coordenadas o vectores. Es decir, te dice qu√© tan lejos est√° un punto del otro.
  
- ¬øPara qu√© sirven los m√©todos normalize() y limit()?
  > - normalize(): Sirve para conviertir un vector en un vector unitario, es decir, con la misma direcci√≥n pero con magnitud 1.
      Es muy util cuando te interesa solo la direcci√≥n del vector, no su tama√±o.
  > - limit(): limita la magnitud del vector a un valor m√°ximo.
       Es √∫til para evitar que algo se mueva demasiado r√°pido o con una fuerza excesiva en simulaciones o animaciones.

### Actividad 05

- El c√≥digo que genera el resultado que te ped√≠.
  
```javascript
function setup() {
    createCanvas(400, 400);
}

function draw() {
    background(240);

    let v0 = createVector(120, 110);
    let v1 = createVector(200, 0);
    let v2 = createVector(0, 200);
    let t = (sin(frameCount * 0.02) + 1) / 2;
    let v3 = p5.Vector.lerp(v1, v2, t);
    let V4 = p5. Vector.add (v0, v1);
    let V5 = p5. Vector.sub (v2, v1);
    let c = lerpColor('red', 'blue', t); 
    drawArrow(v0, v1, 'red');
    drawArrow(v0, v2, 'blue');
    drawArrow(v0, v3, c);
    drawArrow(V4, V5, 'green');
}

function drawArrow(base, vec, myColor) {
    push();
    stroke(myColor);
    strokeWeight(2);
    fill(myColor);
    translate(base.x, base.y);
    line(0, 0, vec.x, vec.y);
    rotate(vec.heading());
    let arrowSize = 6;
    translate(vec.mag() - arrowSize, 0);
    triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
    pop();
}
  
```
- ¬øC√≥mo funciona lerp() y lerpColor().

  > - ***Funci√≥n lerp():*** Esta funci√≥n permite encontrar un valor intermedio entre dos n√∫meros (a y b). En terminos de animaci√≥n animaci√≥n, act√∫a como una interpolaci√≥n entre esos dos puntos clave (keyframes), generando los valores in-between. El tercer par√°metro representa el porcentaje del recorrido entre a y b, siendo 0 el inicio (a) y 1 el final (b). Si este par√°metro es por ejemplo 0.5, el resultado estar√° justo en la mitad. pero si definimos el parametro t, que puede variar con el tiempo, lo que obtendremos es una transiciones suave y constante del recorrido de a a b en el tiempo lo que da  una animaci√≥n fluida.
  > - ***Funci√≥n LerpColor():*** Funciona de manera similar a lerp(), pero aplicada a colores. Interpola entre dos colores definidos (por ejemplo, colorA y colorB) y devuelve un color intermedio seg√∫n el valor del tercer par√°metro. Cuando este se usa como una variable dependiente del tiempo, se produce una transici√≥n gradual entre los dos colores.
  
- ¬øC√≥mo se dibuja una flecha usando drawArrow()?

  > Primero la funci√≥n llama al punto de origen (base) en la direcci√≥n de un vector (vec). El vector indica hacia d√≥nde apunta y qu√© tan larga es la flecha. Se traduce al punto base, se dibuja una l√≠nea, se rota seg√∫n la direcci√≥n con rotatataci√≥n y se a√±ade una punta. 

### Actividad 06

**Motion 101**
- Cu√°l es el concepto del marco motion 101 y c√≥mo se interpreta geom√©tricamente.
> El Motion 101 se basa en una l√≥gica simple para animar objetos mediante vectores: sumar la velocidad a la posici√≥n en cada frame (position.add(velocity)) y luego dibujar el objeto en esa nueva posici√≥n. Esta      operaci√≥n shace  continuamente, es decir se repite muchas veces, creando as√≠ un movimiento fluido. Geom√©tricamente, puede imaginarse como una flecha (velocity) que se a√±ade a otra (position), desplazando el objeto en la direcci√≥n y con la magnitud indicadas por el vector de la velocidad.
- ¬øC√≥mo se aplica motion 101 en el ejemplo?
En este ejemplo, Motion 101 se aplica dentro del m√©todo update() de la clase Mover, donde la posici√≥n del objeto se actualiza sum√°ndole su velocidad (this.position.add(this.velocity)). Luego, en draw(), se llama a show() para dibujar el objeto en su nueva posici√≥n. Este ciclo se repite en cada frame, genrando la ilusi√≥n de movimiento.

### Actividad 07
¬øQu√© observaste cuando usas cada una de las aceleraciones propuestas?
- 



